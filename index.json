[{"categories":["espressif"],"content":"这篇文章简单介绍ESP-IDF.","date":"2022-04-30","objectID":"/esp-idf/","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"esp-idf 是乐鑫官方的物联网开发框架，适用于 ESP32、ESP32-S 和 ESP32-C 系列 SoC。它基于 C/C++ 语言提供了一个自给自足的 SDK，方便用户在这些平台上开发通用应用程序。 相较于传统MCU厂商提供的SDK组件，IDF更接近开源模板，集成丰富的使用案例资源，尤其是广泛吸纳开源资源，是开发趋势的直观呈现，当然这一特性，对于最求底层稳定，上层差异化的应用开发者十分恼火。 ","date":"2022-04-30","objectID":"/esp-idf/:0:0","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"System ","date":"2022-04-30","objectID":"/esp-idf/:1:0","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"timer  64-bit hardware timer相较于FreeRTOS软定时器具有更高精度。 #include \"esp_timer.h\" #include \"esp_timer_impl.h\" 调用接口: esp_timer_init(void) esp_timer_create(const esp_timer_create_args_t *create_args, esp_timer_handle_t *out_handle) esp_timer_start_once(esp_timer_handle_t timer, uint64_t timeout_us) esp_timer_start_periodic(esp_timer_handle_t timer, uint64_t period) esp_timer_stop(esp_timer_handle_t timer) esp_timer_delete(esp_timer_handle_t timer) typedef struct { esp_timer_cb_t callback; //!\u003c Function to call when timer expires void* arg; //!\u003c Argument to pass to the callback esp_timer_dispatch_t method; //!\u003c Call the callback from task or from ISR const char* name; //!\u003c Timer name, used in esp_timer_dump function bool skip_unhandled_events; //!\u003c Skip unhandled events for periodic timers } esp_timer_create_args_t; 获取状态: esp_timer_dump(stdout); int64_t esp_timer_get_time(void); int64_t esp_timer_get_next_alarm(void); bool esp_timer_is_active(esp_timer_handle_t timer); ","date":"2022-04-30","objectID":"/esp-idf/:1:1","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"sleep 不同芯片的低功耗策略不同，针对ESP32-S3而言，可以通过不同唤醒源退出。 #include \"esp_sleep.h\" 唤醒源： Timer: esp_sleep_enable_timer_wakeup(uint64_t time_in_us) Touch : esp_sleep_enable_touchpad_wakeup() RTC GPIO : esp_sleep_enable_ext0_wakeup(gpio_num_tgpio_num, int level) RTC GPIO : esp_sleep_enable_ext1_wakeup(uint64_t mask, esp_sleep_ext1_wakeup_mode_t mode) ULP : esp_sleep_enable_gpio_wakeup(void) Deep sleep 一般而言，追求低功耗会优先考虑极低的可能，对应在ESP芯片上就是Deep Sleep模式 Light sleep 由于芯片时钟域的不同，在极低功耗的Deep Sleep模式下，很多功能是无法使用的，所以可以退而求其次，采用light sleep模式 UART : esp_sleep_enable_uart_wakeup(int uart_num) GPIO : esp_sleep_enable_uart_wakeup(int uart_num) ","date":"2022-04-30","objectID":"/esp-idf/:1:2","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"Wireless ","date":"2022-04-30","objectID":"/esp-idf/:2:0","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"Wi-Fi ","date":"2022-04-30","objectID":"/esp-idf/:2:1","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"Bluetooth BLE 作为蓝牙物联网领域的主要应用模式，适用于 ESP32、ESP32-S3 和 ESP32-C 系列 Classic CLASSIC BT 目前只有ESP32支持，主要应用于音频领域。 SPP HFP A2DP ","date":"2022-04-30","objectID":"/esp-idf/:2:2","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"Protocols ","date":"2022-04-30","objectID":"/esp-idf/:3:0","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"MQTT  MQTT is a lightweight publish/subscribe messaging protocol ESP-MQTT ","date":"2022-04-30","objectID":"/esp-idf/:3:1","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"HTTP ","date":"2022-04-30","objectID":"/esp-idf/:3:2","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"OpenSSL ","date":"2022-04-30","objectID":"/esp-idf/:3:3","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"Modbus ESP-Modbus ","date":"2022-04-30","objectID":"/esp-idf/:3:4","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"Peripherals ","date":"2022-04-30","objectID":"/esp-idf/:4:0","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"ADC #include \"driver/adc.h\" ","date":"2022-04-30","objectID":"/esp-idf/:4:1","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"PWM #include \"driver/mcpwm.h\" ","date":"2022-04-30","objectID":"/esp-idf/:4:2","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"Touch  ESP32-S3 最多可支持 14 个电容式触摸传感器通道/GPIO。 #include \"driver/touch_pad.h\" ","date":"2022-04-30","objectID":"/esp-idf/:4:3","tags":["esp-idf","api","espressif"],"title":"ESP-IDF","uri":"/esp-idf/"},{"categories":["espressif"],"content":"这篇文章简单介绍esp-adf.","date":"2022-04-26","objectID":"/esp-adf/","tags":["esp-adf","api","espressif"],"title":"ESP-ADF","uri":"/esp-adf/"},{"categories":["espressif"],"content":"esp-adf 是乐鑫官方的音频开发框架，适用于 ESP32、ESP32-S 和 ESP32-C 系列 SoC。它基于 C/C++ 语言提供了一个自给自足的 SDK，方便用户在这些平台上开发通用应用程序。 ","date":"2022-04-26","objectID":"/esp-adf/:0:0","tags":["esp-adf","api","espressif"],"title":"ESP-ADF","uri":"/esp-adf/"},{"categories":["espressif"],"content":"这篇文章简单介绍esp-mdf.","date":"2022-04-25","objectID":"/esp-mdf/","tags":["esp-mdf","api","espressif"],"title":"ESP-MDF","uri":"/esp-mdf/"},{"categories":["espressif"],"content":"esp-mdf 是乐鑫mesh开发框架，适用于 ESP32、ESP32-S 和 ESP32-C 系列 SoC。 目前该项目并不很活跃，主要的成果可以在ESP-IDF中找到，同样的mesh功能实现还包括BLE-Mesh和ESP-NOW ","date":"2022-04-25","objectID":"/esp-mdf/:0:0","tags":["esp-mdf","api","espressif"],"title":"ESP-MDF","uri":"/esp-mdf/"},{"categories":["espressif"],"content":"这篇文章总结WiFi.","date":"2022-03-28","objectID":"/wifi/","tags":["Wi-Fi","espressif"],"title":"Wi-Fi","uri":"/wifi/"},{"categories":["espressif"],"content":"Beacon Beacon-Interval(信标间隔)，这个值变大，有助于client端省电。这个值变小，有助于提高client端连接速度。降低了基地台的buffer frame负载。一般预设为100mS。以Beacons 封包发送SSID的速率是1Mbit/S. Listen-Interval(STA接收Beacon的周期)，AP广播Beacon的周期为Beacon-Interval，STA可以自由选择Beacon-Interval整数倍作为自己的Listen-Interval，比如10。 STA每隔Listen-Interval接收Beacon并解码其中的TIM，如果TIM 指示没有数据缓存，STA 就可以立刻转入Doze状态，如果TIM 指示其有数据缓存，STA 就要向AP 发一个竞选控制包Poll，AP 在收到Poll 后就可以向该Poll 的源STA 发送一个为它缓存的数据包。 ","date":"2022-03-28","objectID":"/wifi/:1:0","tags":["Wi-Fi","espressif"],"title":"Wi-Fi","uri":"/wifi/"},{"categories":["espressif"],"content":"DTIM 每一个Beacon的帧中都有一个TIM(traffic indication message)信息元素，它主要用来由AP通告它管辖下的哪个STA有信息现在缓存在AP中，而在TIM中包含一个 Bitmap control 字段，它最大是251个字节，每一位映射一个STA，当为1时表示该位对应的STA有信息在AP中。 STA收到与自己关联的TIM就要发送PS-POLL帧来与AP取来联系并取得它的缓存帧，标准的TIM中仅仅指示AP缓存的单播信息。 DTIM(Delivery Traffic Indication Message)是TIM的特殊情况，当发送几个TIM之后，就要发送一个DTIM，其除了缓存单播信息，也同时指示AP缓存的组播或广播信息，一旦AP发送了DTIM, STA就必须处于清醒，因为广播或组播无重发机制，不醒来数据就收不到了。 DTIM用于AP传统节电模式中，多点的应用，即由AP通过设置DTIM的间隔（缺省是一个beacon时间，100ms），根据这个间隔发送组播流量。 也就是说DTIM里面会指示是否有组播数据，也会指示是否有单播数据。 如果beacon包含的DTIM里面有组播数据，也包含了单播的数据。STA会马上唤醒，接受组播数据，接受完成之后，会继续接收单播数据。 ","date":"2022-03-28","objectID":"/wifi/:2:0","tags":["Wi-Fi","espressif"],"title":"Wi-Fi","uri":"/wifi/"},{"categories":["espressif"],"content":"Multicast 根据协议，Broadcast 和 Multicast(组播) 在DTIM的时候AP会发送给STA。DTIM在AP中的设置一般是一倍的TIM。 当DTIM增加的时候会更加省电，因为出于PS模式下的STA醒来的次数变少了，但是这也会导致某些应用的延时加大。 在以太网数据帧头中会需要指定发送以及接受设备的MAC地址，以确定该数据包的来源与去向，广播时接收方的MAC地址为0xFFFFFFFFFFFF，单播时接收方的MAC地址为对端MAC地址，而组播时，接收方的MAC地址则与组地址之间有一个映射关系，而WiFi组播配网正是利用了这个组地址与MAC地址的映射。判断一个MAC是否为组播MAC的依据是MAC地址的第一个字节的bit0是否为１。 ","date":"2022-03-28","objectID":"/wifi/:3:0","tags":["Wi-Fi","espressif"],"title":"Wi-Fi","uri":"/wifi/"},{"categories":["espressif"],"content":"这篇文章总结OTA.","date":"2022-03-27","objectID":"/ota/","tags":["ota","espressif"],"title":"OTA","uri":"/ota/"},{"categories":["espressif"],"content":"OTA (Over-the-Air) 通过无线方式实现固件升级 ","date":"2022-03-27","objectID":"/ota/:0:0","tags":["ota","espressif"],"title":"OTA","uri":"/ota/"},{"categories":["espressif"],"content":"ESP OTA ESP OTA 基于多分区管理，提供基于WiFi和蓝牙的空中升级方式，特别是通过https连接获取固、完整性校验和回滚机制等整套解决方案，开发者基于 esp_https_ota 组件获得很高的开发起点。 ","date":"2022-03-27","objectID":"/ota/:1:0","tags":["ota","espressif"],"title":"OTA","uri":"/ota/"},{"categories":["espressif"],"content":"这篇文章总结jira使用.","date":"2022-03-24","objectID":"/jira/","tags":["jira","espressif"],"title":"jira","uri":"/jira/"},{"categories":["espressif"],"content":"简介 Jira是Atlassian公司出品的一款事务管理软件。无论是“需求”，还是“BUG”，或是“任务”，都是“事务”的一种，所以Jira可以胜任非常多的角色：需求管理、缺陷跟踪、任务管理等等……因为Jira提供了专门的Scrum视图和Kanban视图，所以特别适合敏捷开发团队使用。大型互联网公司如LinkedIn、Facebook、eBay等内部都在使用Jira。 Project项目 Issue事务 Field字段 Workflow工作流 Screen视图 ","date":"2022-03-24","objectID":"/jira/:1:0","tags":["jira","espressif"],"title":"jira","uri":"/jira/"},{"categories":["espressif"],"content":"Project 在项目管理范畴内可以看作“项目”的，都是Jira中的项目。Project是Issue的容器。在创建项目时，JIRA会要求你指定“KEY”，这个KEY加上数字，就是Issue的唯一ID了。比如新建一个项目，KEY设置为WEB，那么项目下的第一条Issue就是WEB-1，第二条Issue是WEB-2，依此类推。 ","date":"2022-03-24","objectID":"/jira/:2:0","tags":["jira","espressif"],"title":"jira","uri":"/jira/"},{"categories":["espressif"],"content":"Issue Issue是Jira核心中的核心，它分为以下几种类型： Story 故事（即敏捷开发中的“用户故事”） Epic 史诗 Improvement 提升 New Feature 新特性 Bug 缺陷 Task 任务 Sub-Task 子任务 ","date":"2022-03-24","objectID":"/jira/:3:0","tags":["jira","espressif"],"title":"jira","uri":"/jira/"},{"categories":["espressif"],"content":"Field 一个Story会有属性：名称、详细描述、提交人、提交时间、优先级、状态等等。这些属性就是Field字段。而所谓的Story，也是Type属性为“Story”的Issue而已，把Type属性改成“Epic”，那这个Story就会变成Epic了。 ","date":"2022-03-24","objectID":"/jira/:4:0","tags":["jira","espressif"],"title":"jira","uri":"/jira/"},{"categories":["espressif"],"content":"Workflow 任务会有不同的状态：待办，进行中，已完成；需求也会有不同的状态：刚提交，待评审，暂缓，已拒绝，开发中，已完成，等等。Workflow就是用来定义定义Issue的状态。 Workflow由两部分组成： Status 状态 Transition 转换动作 ","date":"2022-03-24","objectID":"/jira/:5:0","tags":["jira","espressif"],"title":"jira","uri":"/jira/"},{"categories":["espressif"],"content":"Screen Screen（视图）还会衍生Screen Scheme和Issue Type Screen Scheme两个概念。Screen这个概念就像空气一样，理所当然，可是对于不懂化学的人来说又无法描述。所以这个我们后面再详细介绍。只要知道，我们在新建Issue、编辑Issue、查看Issue详情时，其实是通过“新建视图”、“编辑视图”、“详情视图”完成的就好了。 ","date":"2022-03-24","objectID":"/jira/:6:0","tags":["jira","espressif"],"title":"jira","uri":"/jira/"},{"categories":["espressif"],"content":"这篇文章总结Espressif编程开发.","date":"2022-03-15","objectID":"/espressif/","tags":["tools","espressif"],"title":"Espressif","uri":"/espressif/"},{"categories":["espressif"],"content":"编程规范 1、任何只在单个源文件中使用的变量或函数都应该被声明为静态的（static） 1.1 静态变量应该以s_为前缀，以便于识别 2、公共名称（非静态变量和函数）应该用每个组件或每个单元的前缀来命名，以避免命名冲突 3.非必要避不用缩写（即把data缩短为dat） 4.每个缩进级别使用4个空格，不要使用制表符来缩进 5.函数之间空行隔开，函数｛｝中不要以空行开始或结束 6.只要不严重影响可读性，最大行长为120个字符 7.始终在if、switch、for等条件和循环关键词后面添加个空格，而不是直接加() 7.1 在二进制运算符周围添加单个空格 7.2 单数运算符不需要空格 7.3 乘法和除法运算符周围可以去掉空格v 8 有时在一行中添加空格使代码垂直对齐，使代码更易读 8.1 要少用水平对齐，特别是当你预计以后会有新的行被添加到列表中时 9 不要在行末添加尾部的空白 10 如果暂时禁用某些调用，并打算在将来恢复它，请在相邻行加注释 10.1 对于#if 0 #endif块。如果不使用就完全删除它。否则，添加注释，解释为什么该块被禁用 10.2 不要添加修改日期之类的琐碎的注释，因为这些信息都是可以通过git查出的 11 提交的文件应该只包含LF（Unix风格）结尾的文件 // IDF Master在使用时会遇到LF/CRLF问题，相关解决方式 git rebase --exec 'git diff-tree --no-commit-id --name-only -r HEAD | xargs dos2unix \u0026\u0026 git commit -a --amend --no-edit --allow-empty' master //针对单个文件的转码可使用 dos2unix FILENAME 12 如果不是重构或新加一个文件，不要去改变文件格式，这样便于review修改部分 13 配置ESP-IDF可禁用断言assert()，在默认配置中，返回false或0的assert条件将调用abort()并触发一个Fatal Error 14 共用头文件需要预处理保护机制，如 #pragma once / #ifndef FILE_NAME_H … #endif 15 共用头文件需要加入 extern “C” 实现和C++代码的兼容 16 在#include其他文件时，尽量保持如下顺序 //对C语言标准库头文件和其他POSIX头文件使用角括号，格式如 #include \u003cstdio.h\u003e * C standard library headers. * Other POSIX standard headers and common extensions to them (such as sys/queue.h.) * Common IDF headers (esp_log.h, esp_system.h, esp_timer.h, esp_sleep.h, etc.) * Headers of other components, such as FreeRTOS. * Public headers of the current component. * Private headers. ","date":"2022-03-15","objectID":"/espressif/:1:0","tags":["tools","espressif"],"title":"Espressif","uri":"/espressif/"},{"categories":["espressif"],"content":"开发环境 使用ESP系列芯片，和使用传统的MCU最大的差异在于核心思想，ESP的产品可以看作微型服务器，将互联网领域对server的一些应用同步到单片机上，这在很多的应用案例上都有体现，所以对开发者的跨领域知识要求比较高，而官方的开发框架和应用案例，更多是为了让跨度显得没那么大，因为既懂gcc又懂gulp的工程师太稀有。 ","date":"2022-03-15","objectID":"/espressif/:2:0","tags":["tools","espressif"],"title":"Espressif","uri":"/espressif/"},{"categories":["espressif"],"content":"固件烧录 esptool esptool 是乐鑫提供的开源库工具，用于乐鑫芯片和 ROM Bootloader（一级 bootloader）通讯，从而实现：固件烧录，flash 擦除，flash 读取，读 MAC 地址，读 flash id ，elf 文件转 bin 等常用功能；flash 校验, 读取内存，载入 bin 到 RAM 执行，读内存，写内存，读 flash 状态，写 flash 状态，读 chip id，组装 bin等高级功能。 esptool.py read_mac esptool.py flash_id 通常设备有多个 MAC 地址，例如做 station 的 MAC 地址，做 softAP 时的 MAC 地址，这里读取的是 MAC 地址是 station 地址 自动读取从 0x0 地址开始的 4KB 内容，保存到 dump.bin 文件 esptool.py read_flash 0x0 0x1000 dump.bin esptool.py erase_region 0x20000 0x4000 esptool.py --chip esp32c3 merge_bin -o test_flash_c3.bin --flash_mode dio --flash_freq 80m --flash_size 2MB 0x0 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin 0x10000 build/uart_test.bin 精简后： esptool.py --chip esp32c3 merge_bin -o test_flash_c3.bin 0x0 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin 0x10000 build/uart_test.bin ","date":"2022-03-15","objectID":"/espressif/:2:1","tags":["tools","espressif"],"title":"Espressif","uri":"/espressif/"},{"categories":["espressif"],"content":"ESP-IDF ","date":"2022-03-15","objectID":"/espressif/:3:0","tags":["tools","espressif"],"title":"Espressif","uri":"/espressif/"},{"categories":["espressif"],"content":"Docker https://hub.docker.com/r/espressif/idf docker pull espressif/idf sudo docker run --rm --privileged -v $PWD:/project -w /project espressif/idf:release-v4.4 idf.py build sudo docker run --rm --privileged -v /dev:/dev -v $PWD:/project -w /project espressif/idf:release-v4.4 idf.py fullclean build flash sudo docker run --rm --privileged -v /dev:/dev -v $PWD:/project -w /project espressif/idf:release-v4.4 idf.py set-target esp32s3 build flash -w: 指定命令执行时，所在的路径 –rm：容器停止自动删除容器 alias esp-idf='docker run --rm --privileged -v /dev:/dev -v $PWD:/project -w /project -it espressif/idf:v4.4 bash -c' 执行docker run命令带–rm命令选项，等价于在容器退出后，执行docker rm -v。–rm选项不能与-d同时使用，即只能自动清理foreground容器，不能自动清理detached容器，–rm选项也会清理容器的匿名data volumes。 esp-idf \"idf.py -p /dev/ttyUSB0 flash\" esp-idf \"idf.py -p /dev/ttyUSB0 monitor\" ESP-Update-Server docker run -tid -p 8000:8000 --name fw-server -v $PWD:/firmware sglahn/ota-server url -X GET \\ http://localhost:8000/firmware \\ -H 'x-ESP8266-version: 1.0' ","date":"2022-03-15","objectID":"/espressif/:3:1","tags":["tools","espressif"],"title":"Espressif","uri":"/espressif/"},{"categories":["espressif"],"content":"ESP-ADF ESP-ADF ","date":"2022-03-15","objectID":"/espressif/:4:0","tags":["tools","espressif"],"title":"Espressif","uri":"/espressif/"},{"categories":["espressif"],"content":"ESP-MDF ","date":"2022-03-15","objectID":"/espressif/:5:0","tags":["tools","espressif"],"title":"Espressif","uri":"/espressif/"},{"categories":["Linux"],"content":"这篇文章总结Docker使用.","date":"2022-03-09","objectID":"/docker/","tags":["Linux","Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Linux"],"content":"简介 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 ","date":"2022-03-09","objectID":"/docker/:1:0","tags":["Linux","Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Linux"],"content":"使用 docker run -it -v /test:/soft centos /bin/bash -t：–tty，分配终端 -i：–interactive,交互式启动 -d：–detach，后台运行 -v：–volume,挂在数据卷 -e, –env list 设置env 这样在容器启动后，容器内会自动创建/soft的目录。通过这种方式，我们可以明确一点，即-v参数中，冒号\":“前面的目录是宿主机目录，后面的目录是容器内目录。 docker run -it --privileged=true -v /test:/soft centos /bin/bash 指定–privileged参数解决“Permission denied” runoob教程 ","date":"2022-03-09","objectID":"/docker/:2:0","tags":["Linux","Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Linux"],"content":"容器 ","date":"2022-03-09","objectID":"/docker/:3:0","tags":["Linux","Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Linux"],"content":"gogs sudo docker run -itd --name=gogs -p 10022:22 -p 10880:3000 -v /home/ubuntu/gogs:/data gogs/gogs ","date":"2022-03-09","objectID":"/docker/:3:1","tags":["Linux","Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Linux"],"content":"gitea ","date":"2022-03-09","objectID":"/docker/:3:2","tags":["Linux","Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Linux"],"content":"互访 目前的容器间互访基本都是基于网络端口实现。 docker run –link 可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。 ","date":"2022-03-09","objectID":"/docker/:4:0","tags":["Linux","Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Linux"],"content":"K8S K8S 全称 Kubernetes , 是谷歌开源的容器管理系统，构建在Docker之上，深度整合了Docker，提供资源排程、部署执行、服务发现、扩充缩容等一整套工具。 从架构设计层面，我们关注的可用性，伸缩性都可以结合k8s得到很好的解决，如果你想使用微服务架构，搭配k8s，真的是完美，再从部署运维层面，服务部署，服务监控，应用扩容和故障处理，k8s都提供了很好的解决方案。 具体包括以下几点： 服务发现与调度 负载均衡 服务自愈 服务弹性扩容 横向扩容 存储卷挂载 ","date":"2022-03-09","objectID":"/docker/:5:0","tags":["Linux","Docker"],"title":"Docker","uri":"/docker/"},{"categories":["tools"],"content":"这篇文章总结Git使用.","date":"2022-03-08","objectID":"/git/","tags":["Git","Github"],"title":"Git","uri":"/git/"},{"categories":["tools"],"content":"rebase  不要通过rebase对任何已经提交到公共仓库中的commit进行修改 git rebase -i [startpoint] [endpoint] git rebase -i HEAD~3 git rebase -i 36224db pick：保留该commit（缩写:p） reword：保留该commit，但我需要修改该commit的注释（缩写:r） edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e） squash：将该commit和前一个commit合并（缩写:s） fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f） exec：执行shell命令（缩写:x） drop：我要丢弃该commit（缩写:d） 将该指定的提交复制到对应分支 git rebase [startpoint] [endpoint] --onto [branchName] ","date":"2022-03-08","objectID":"/git/:1:0","tags":["Git","Github"],"title":"Git","uri":"/git/"},{"categories":["tools"],"content":"prune error: cannot lock ref ‘refs/remotes/origin/master’ 发生这个情况的原因是本地的 reference 和云端的不一样时导致的，因此同步一下双方的 reference 即可。 git remote prune origin 可以清理远程的本地分支，但是不会动本地的开发分支。 ","date":"2022-03-08","objectID":"/git/:2:0","tags":["Git","Github"],"title":"Git","uri":"/git/"},{"categories":["IoT"],"content":"这篇文章总结Camera相关知识.","date":"2022-03-06","objectID":"/camera/","tags":["Camera","DVP","USB"],"title":"Camera","uri":"/camera/"},{"categories":["IoT"],"content":"简介 sensor（图像传感器）是一种半导体芯片，有两种类型：电荷耦合器件CCD（Charge Coupled Device） 和 互补金属氧化物半导体CMOS（Complementary Metal-Oxide Semiconductor）。 CCD传感器，电荷信号先传送，后放大，再A/D，成像质量灵敏度高、分辨率好、噪声小；处理速度慢；造价高，工艺复杂。 CMOS传感器，电荷信号先放大，后A/D，再传送；成像质量灵敏度低、噪声明显；处理速度快；造价低，工艺简单。  ISP（图像信号处理） 主要完成数字图像的处理工作，把 sensor 采集到的原始数据转换为对应格式。 ","date":"2022-03-06","objectID":"/camera/:1:0","tags":["Camera","DVP","USB"],"title":"Camera","uri":"/camera/"},{"categories":["IoT"],"content":"OV2640 支持：RGB565或JPEG输出 UKCA,即分辦率位16001200的输出格式。类似的还有：SXGA(12801024)、XVGA(1280960)、WXGA(1280800)、XGA(1024768)、SVGA(800600)、VGA(640ド480)、CIF(352288)和 QQVGA(160120)等。 PCLK,即像素时钟,一个PCLK时钟,输出一个(或半个)像素。VSYNC,即帧同步信号。HREF/ HSYNC,即行同步信号。 ","date":"2022-03-06","objectID":"/camera/:1:1","tags":["Camera","DVP","USB"],"title":"Camera","uri":"/camera/"},{"categories":["IoT"],"content":"interface USB（Universal Serial Bus）串行通用串行总线 MIPI是移动行业处理器接口（Mobile Industry Processor Interface） DVP是数字视频端口（digital video port）的简称 CSI是相机串行接口（CMOS Sensor Interface）的简称 ","date":"2022-03-06","objectID":"/camera/:2:0","tags":["Camera","DVP","USB"],"title":"Camera","uri":"/camera/"},{"categories":["IoT"],"content":"DVP DVP总线PCLK极限约在96M左右，而且走线长度不能过长，所有DVP最大速率最好控制在72M以下，PCB layout较容易画；MIPI总线速率lvds接口耦合，走线必须差分等长，并且需要保护，故对PCB走线以及阻抗控制要求高一点（一般来讲差分阻抗要求在85欧姆~125欧姆之间）。 DVP是并口，需要PCLK、VSYNC、HSYNC、D[0：11]——可以是8/10/12bit数据，看ISP或baseband是否支持； MIPI是LVDS（Low Voltage Differential Signaling，低电压差分信号），低压差分串口。只需要要CLKP/N、DATAP/N——最大支持4-lane，一般2-lane可以搞定。 MIPI接口比DVP的接口信号线少，由于是低压差分信号，产生的干扰小，抗干扰能力也强。 最重要的是DVP接口在信号完整性方面受限制，速率也受限制。500W还可以勉强用DVP，800W及以上都采用MIPI接口。 ","date":"2022-03-06","objectID":"/camera/:2:1","tags":["Camera","DVP","USB"],"title":"Camera","uri":"/camera/"},{"categories":["IoT"],"content":"MIPI MIPI是差分串口传输，速度快，抗干扰。主流手机模组现在都是用MIPI传输，传输时使用4对差分信号传输图像数据和一对差分时钟信号；最初是为了减少LCD屏和主控芯片之间连线的数量而设计的，后来发展到高速了，支持高分辨率的显示屏，现在基本上都是MIPI接口。 ","date":"2022-03-06","objectID":"/camera/:2:2","tags":["Camera","DVP","USB"],"title":"Camera","uri":"/camera/"},{"categories":["IoT"],"content":"CSI CSI-2接口规范是由MIPI(Mobile Industry Processor Interface)联盟组织于2005年发布的关于相机串行接口，它作为一种全新的相机设备和处理器之间的接口框架，给便携式、手机摄像头等相关产业提供了一种灵活且高速的设备接口。 ","date":"2022-03-06","objectID":"/camera/:2:3","tags":["Camera","DVP","USB"],"title":"Camera","uri":"/camera/"},{"categories":["Linux"],"content":"这篇文章总结了基本的Linux使用.","date":"2022-03-06","objectID":"/linux/","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Espressif乐鑫 日常工作依赖于LinuxUbuntu 开发环境，在此总常用的操作命令及快捷方式，便于判断知识边界和提高复习效率。 ","date":"2022-03-06","objectID":"/linux/:0:0","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"系统简介 关于Linux的书籍和文章非常多，不同的应用目的常用的工具和指令是不同的，学习的重点可能会有些许差异，在此总结最通用的基础部分。 Linux 只是一个内核。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。 Linux 的发行版本可以大体分为两类： 商业公司维护的发行版本，以著名的 Red Hat 为代表； 社区组织维护的发行版本，以 Debian 为代表。 把 Red Hat、Ubuntu、SUSE 等直接说成 Linux 其实是不确切的，它们是 Linux 的发行版本，更确切地说，应该叫作“以Linux为核心的操作系统软件包”。 ","date":"2022-03-06","objectID":"/linux/:1:0","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Ubuntu Ubuntu 基于知名的 Debian Linux 发展而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本，而且 Ubuntu 的所有发行版本都免费提供。 软件管理 系统默认包管理工具为 apt apt-get命令是Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。 我们常用的Ubuntu就是一个基于Debian的发行，我们使用apt-get命令获取这个列表，以下是我整理的常用命令： sudo apt-get update 更新源 sudo apt-get install package 安装包 sudo apt-get remove package 删除包 sudo apt-cache search package 搜索软件包 sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package --reinstall 重新安装包 sudo apt-get -f install 修复安装 sudo apt-get remove package --purge 删除包，包括配置文件等 sudo apt-get build-dep package 安装相关的编译环境 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-cache depends package 了解使用该包依赖那些包 sudo apt-cache rdepends package 查看该包被哪些包依赖 sudo apt-get source package 下载该包的源代码 sudo apt-get clean \u0026\u0026 sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 apt-key命令用于管理Debian Linux系统中的软件包密钥。每个发布的deb包，都是通过密钥认证的，apt-key用来管理密钥。操作指令：APT密钥操作指令。 apt-key list #列出已保存在系统中key。 apt-key add keyname #把下载的key添加到本地trusted数据库中。 apt-key del keyname #从本地trusted数据库删除key。 apt-key update #更新本地trusted数据库，删除过期没用的key。 配置软件安装源 sources.list系统自带的，源是来Ubuntu的官网！安装包比较慢，所以最好切换成国内的 qitas@ubuntu:~$ cd /etc/apt qitas@ubuntu:/etc/apt$ sudo cp sources.list sources.list.bak qitas@ubuntu:/etc/apt$ vim sources.list ","date":"2022-03-06","objectID":"/linux/:1:1","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"技能补全 ","date":"2022-03-06","objectID":"/linux/:2:0","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"快捷操作 clear(完全清除，无法向上翻页查看之前信息) ctrl+L（屏幕清除，开启新行，依旧可以向上翻页查看之前信息） date 查看系统时间 cat 正常文件查看 tac 从最后一行开始显示 nl 显示是会输出行号 可翻页查看(只向后)：more，按q停止 可翻页查看(可向前或向后)：less，按q停止 ","date":"2022-03-06","objectID":"/linux/:2:1","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"用户管理 查看当前的用户: sudo adduser db ls -l /etc/passwd ls -l /etc/shadow ls -l /etc/group sudo adduser db passwd db sudo vim /etc/sudoers # User privilege specification root ALL=(ALL) ALL db ALL=(ALL) ALL ","date":"2022-03-06","objectID":"/linux/:2:2","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"文件处理 改变所属用户chown（应该首先改） ​ chown user text.txt 改文件权限chmod ​ chmod 770 test.txt ​ chmod u+r test.txt ​ chmod u=rw test.txt 改文件所属组 chgrp user_grp text.txt ","date":"2022-03-06","objectID":"/linux/:2:3","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"网络管理 编辑网卡配置文件：sudo vi /etc/network/interfaces auto eth0 iface eth0 inet dhcp or auto eth0 iface eth0 inet static address 192.168.3.90 gateway 192.168.3.1 netmask 255.255.255.0 ","date":"2022-03-06","objectID":"/linux/:2:4","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"显示输出 在使用shell语法时，对于\u0026 1 更准确的说应该是文件描述符 1,而1标识标准输出，stdout。对于2 ，表示标准错误，stderr。 2\u003e\u00261 的意思就是将标准错误重定向到标准输出。这里标准输出已经重定向到了 /dev/null。那么标准错误也会输出到/dev/null 把/dev/null 可以看作\"黑洞\". 它等价于一个只写文件. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到，偶尔也可以把 \u0026 在命令的最后加上，表示让程序后台执行。 ls 2\u003e1 测试一下，不会报没有2文件的错误，但会输出一个空的文件1； ls xxx 2\u003e1测试，没有xxx这个文件的错误输出到了1中； ls xxx 2\u003e\u00261测试，不会生成1这个文件了，不过错误跑到标准输出了； ls xxx \u003eout.txt 2\u003e\u00261, 实际上可换成 ls xxx 1\u003eout.txt 2\u003e\u00261；重定向符号\u003e默认是1,错误和输出都传到out.txt了。 ","date":"2022-03-06","objectID":"/linux/:2:5","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"状态查询 常用系统命令包括 Vmstat、sar、iostat、netstat、free、ps、top等 查看活动用户：w 查看用户登录日志：last 查看用户信息：id 查看本机ip: ip a 查看路由表：ip route 查看所有进程：ps -elf 实时查看进程：top 监控CPU状态sar  sar对系统每方面进行单独统计，会增加系统开销，不过开销可以评估，对系统的统计结果影响不大。 下面是sar命令对某个系统的CPU统计输出： [root@webserver ~]# sar -u 3 5 输出解释如下： %user列显示了用户进程消耗的CPU 时间百分比。 %nice列显示了运行正常进程所消耗的CPU 时间百分比。 %system列显示了系统进程消耗的CPU时间百分比。 %iowait列显示了IO等待所占用的CPU时间百分比 %steal列显示了在内存相对紧张的环境下pagein强制对不同的页面进行的steal操作 。 %idle列显示了CPU处在空闲状态的时间百分比。 ","date":"2022-03-06","objectID":"/linux/:2:6","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"VIM Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 用户刚刚启动 vi/vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 ","date":"2022-03-06","objectID":"/linux/:2:7","tags":["Linux","Ubuntu","Shell"],"title":"Linux","uri":"/linux/"},{"categories":["editor"],"content":"这篇文章总结Shell编程开发.","date":"2022-03-05","objectID":"/shell/","tags":["Shell","Linux"],"title":"Shell","uri":"/shell/"},{"categories":["editor"],"content":"简介 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。 由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。 ","date":"2022-03-05","objectID":"/shell/:1:0","tags":["Shell","Linux"],"title":"Shell","uri":"/shell/"},{"categories":["editor"],"content":"这篇文章总结Vscode使用.","date":"2022-03-05","objectID":"/vscode/","tags":["vscode","editor"],"title":"vscode","uri":"/vscode/"},{"categories":["editor"],"content":"简介 VSCode（Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器。该软件支持语法高亮、代码自动补全（又称 IntelliSense）、代码重构、查看定义功能，并且内置了命令行工具和 Git 版本控制系统。用户可以更改主题和键盘快捷方式实现个性化设置，也可以通过内置的扩展程序商店安装扩展以拓展软件功能。 VS Code 使用 Monaco Editor 作为其底层的代码编辑器。和 GitHub 的 Atom一样，Visual Studio Code 也基于 Electron 框架构建。 VScode官网：https://code.visualstudio.com ","date":"2022-03-05","objectID":"/vscode/:1:0","tags":["vscode","editor"],"title":"vscode","uri":"/vscode/"},{"categories":["editor"],"content":"功能 前段时间Github更新了一个重磅级功能，我们在Github上浏览任何一个仓库时，只需要点击键盘上的 . 这个键，就可以以该仓库的文件打开一个网页版的代码编辑器 ","date":"2022-03-05","objectID":"/vscode/:2:0","tags":["vscode","editor"],"title":"vscode","uri":"/vscode/"},{"categories":["editor"],"content":"快捷方式 折叠所有区域代码的快捷： ctrl + k ctrl + 0 ; 先按下 ctrl 和 K，再按下 ctrl 和 0; 展开所有折叠区域代码的快捷：ctrl +k ctrl + J ; 先按下 ctrl 和 K，再按下 ctrl 和 J; ","date":"2022-03-05","objectID":"/vscode/:2:1","tags":["vscode","editor"],"title":"vscode","uri":"/vscode/"},{"categories":["editor"],"content":"code-server github # This will start a code-server container and expose it at http://127.0.0.1:8080.# It will also mount your current directory into the container as `/home/coder/project`# and forward your UID/GID so that all file system operations occur as your user outside# the container.## Your $HOME/.config is mounted at $HOME/.config within the container to ensure you can# easily access/modify your code-server config in $HOME/.config/code-server/config.json# outside the container.mkdir -p ~/.configdocker run -it --name code-server -p 127.0.0.1:8080:8080 \\ -v \"$HOME/.config:/home/coder/.config\" \\ -v \"$PWD:/home/coder/project\" \\ -u \"$(id -u):$(id -g)\" \\ -e PASSWORD='登录密码' \\ -e \"DOCKER_USER=$USER\" \\ codercom/code-server:latest code-server目前还不支持在线安装插件，不过它提供了.VSIX方式的安装 wget https://github.com/Microsoft/vscode-python/releases/download/2019.3.6558/ms-python-release.vsix docker run -itd --name coder-idf -p 172.16.0.6:8266:8080 \\ -v \"/home/code:/home/code\" \\ -u \"$(id -u):$(id -g)\" \\ -e PASSWORD='12345678' \\ -e \"DOCKER_USER=$USER\" \\ --restart=always \\ codercom/code-server:latest sudo docker run -itd --name esp-idf-master -p 192.168.171.41:8266:8080 \\ -v \"$HOME/.config:/home/coder/.config\" \\ -v \"$PWD:/home/coder/esp-idf\" \\ -u \"$(id -u):$(id -g)\" \\ -e PASSWORD='12345678' \\ -e \"DOCKER_USER=$USER\" \\ --restart=always \\ codercom/code-server:latest 192.168.171.41 是内网地址，最好是通过root用户运行，避免权限问题 ","date":"2022-03-05","objectID":"/vscode/:3:0","tags":["vscode","editor"],"title":"vscode","uri":"/vscode/"},{"categories":["editor"],"content":"总结展示基本Markdown语法和格式.","date":"2022-03-04","objectID":"/markdown/","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"简介 Markdown 是一种轻量级标记语言，允许人们使用易读易写的纯文本格式编写文档，由约翰·格鲁伯（英语：John Gruber）在2004年创建，编写的文档可以导出HTML 、Word、图像、PDF、Epub 等多种格式的文档。 WYSIWYG所见即所得 的编辑方式可以提供高效的文档撰写体验，各种强大的功能让 Markdown 可以用于生成 HTML 内容。 简单易学, 几乎没有多余的字符, 因此编写内容也更快 书写时出错的机会更少 可以产生有效的XHTML输出 将内容和视觉显示保持分开, 这样就不会打乱网站的外观 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容 Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式!  将此页保存为书签，以备将来参考! ","date":"2022-03-04","objectID":"/markdown/:1:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2022-03-04","objectID":"/markdown/:2:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2022-03-04","objectID":"/markdown/:3:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2022-03-04","objectID":"/markdown/:4:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2022-03-04","objectID":"/markdown/:5:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"5 内联 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2022-03-04","objectID":"/markdown/:6:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"6 强调 ","date":"2022-03-04","objectID":"/markdown/:7:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2022-03-04","objectID":"/markdown/:7:1","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2022-03-04","objectID":"/markdown/:7:2","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2022-03-04","objectID":"/markdown/:7:3","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2022-03-04","objectID":"/markdown/:7:4","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2022-03-04","objectID":"/markdown/:8:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"8 列表 ","date":"2022-03-04","objectID":"/markdown/:9:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2022-03-04","objectID":"/markdown/:9:1","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2022-03-04","objectID":"/markdown/:9:2","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2022-03-04","objectID":"/markdown/:9:3","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"9 代码 ","date":"2022-03-04","objectID":"/markdown/:10:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2022-03-04","objectID":"/markdown/:10:1","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2022-03-04","objectID":"/markdown/:10:2","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2022-03-04","objectID":"/markdown/:10:3","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2022-03-04","objectID":"/markdown/:10:4","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2022-03-04","objectID":"/markdown/:11:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"11 链接 ","date":"2022-03-04","objectID":"/markdown/:12:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2022-03-04","objectID":"/markdown/:12:1","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2022-03-04","objectID":"/markdown/:12:2","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2022-03-04","objectID":"/markdown/:12:3","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2022-03-04","objectID":"/markdown/:13:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"},{"categories":["editor"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2022-03-04","objectID":"/markdown/:14:0","tags":["markdown"],"title":"Markdown","uri":"/markdown/"}]